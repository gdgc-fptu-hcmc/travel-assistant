try:
    from serpapi import Client
except ImportError:
    print("Warning: SERP API not installed. Please run: pip install serpapi")
    Client = None

try:
    from serpapi.google_search import GoogleSearch
except ImportError:
    print("Warning: Google Search Results not installed. Please run: pip install google-search-results")
    GoogleSearch = None

import os
from typing import Dict, Any
from datetime import datetime
from .base_agent import BaseAgent
import logging
import re

try:
    import google.generativeai as genai
except ImportError:
    print("Warning: Google Generative AI not installed. Please run: pip install google-generativeai")
    genai = None

class FlightAgent(BaseAgent):
    def __init__(self):
        """Initialize the Flight Agent."""
        super().__init__()
        
        # ƒê√°nh d·∫•u l√† agent s·ª≠ d·ª•ng API b√™n ngo√†i
        self.uses_external_apis = True
        
        # Get SERP API key
        self.serp_api_key = os.getenv("SERP_API_KEY")
        if not self.serp_api_key:
            logging.warning("SERP_API_KEY not found in environment variables. Flight search will use AI-generated data instead of real-time information.")
        
        # System prompt for the model
        self.system_prompt = """You are a flight booking expert. Your main task is to provide specific flight information. When users ask about flights, ALWAYS show actual flight details.

For any flight query, follow these rules:
1. NEVER just list websites
2. ALWAYS show specific flight information
3. Include all available flights that match the criteria
4. If time of day is specified, show flights for that time period
5. If airline is specified, show flights for that airline

Example responses:

1. For "T√¨m chuy·∫øn bay t·ª´ H√† N·ªôi ƒë·∫øn ƒê√† N·∫µng ng√†y mai, ƒëi v√†o bu·ªïi t·ªëi":
üõ´ C√°c chuy·∫øn bay bu·ªïi t·ªëi t·ª´ H√† N·ªôi ƒë·∫øn ƒê√† N·∫µng ng√†y mai:

1. ‚úàÔ∏è Vietnam Airlines VN125
   üõ´ T·ª´: N·ªôi B√†i (HAN) - 19:00
   üõ¨ ƒê·∫øn: ƒê√† N·∫µng (DAD) - 20:30
   ‚è±Ô∏è Th·ªùi gian bay: 1h30m
   üí∞ Gi√° v√©: 1,800,000 - 2,300,000 VND
   üõÑ H√†nh l√Ω: 7kg x√°ch tay + 23kg k√Ω g·ª≠i
   üí∫ Lo·∫°i m√°y bay: Airbus A321

2. ‚úàÔ∏è Vietjet Air VJ569
   üõ´ T·ª´: N·ªôi B√†i (HAN) - 20:15
   üõ¨ ƒê·∫øn: ƒê√† N·∫µng (DAD) - 21:45
   ‚è±Ô∏è Th·ªùi gian bay: 1h30m
   üí∞ Gi√° v√©: 1,500,000 - 2,000,000 VND
   üõÑ H√†nh l√Ω: 7kg x√°ch tay + 20kg k√Ω g·ª≠i
   üí∫ Lo·∫°i m√°y bay: Airbus A320

3. ‚úàÔ∏è Bamboo Airways QH125
   üõ´ T·ª´: N·ªôi B√†i (HAN) - 21:30
   üõ¨ ƒê·∫øn: ƒê√† N·∫µng (DAD) - 23:00
   ‚è±Ô∏è Th·ªùi gian bay: 1h30m
   üí∞ Gi√° v√©: 1,600,000 - 2,100,000 VND
   üõÑ H√†nh l√Ω: 7kg x√°ch tay + 20kg k√Ω g·ª≠i
   üí∫ Lo·∫°i m√°y bay: Airbus A320

üí° Th√¥ng tin b·ªï sung:
- Gi√° v√© c√≥ th·ªÉ thay ƒë·ªïi t√πy th·ªùi ƒëi·ªÉm ƒë·∫∑t
- N√™n ƒë·∫∑t s·ªõm ƒë·ªÉ c√≥ gi√° t·ªët
- Ki·ªÉm tra ch√≠nh s√°ch h·ªßy/ƒë·ªïi v√© c·ªßa t·ª´ng h√£ng

2. For "T√¨m chuy·∫øn bay t·ª´ H√† N·ªôi ƒë·∫øn ƒê√† N·∫µng ng√†y mai":
üõ´ C√°c chuy·∫øn bay t·ª´ H√† N·ªôi ƒë·∫øn ƒê√† N·∫µng ng√†y mai:

1. ‚úàÔ∏è Vietnam Airlines VN123
   üõ´ T·ª´: N·ªôi B√†i (HAN) - 07:00
   üõ¨ ƒê·∫øn: ƒê√† N·∫µng (DAD) - 08:30
   ‚è±Ô∏è Th·ªùi gian bay: 1h30m
   üí∞ Gi√° v√©: 1,500,000 - 2,000,000 VND
   üõÑ H√†nh l√Ω: 7kg x√°ch tay + 23kg k√Ω g·ª≠i
   üí∫ Lo·∫°i m√°y bay: Airbus A321

2. ‚úàÔ∏è Vietjet Air VJ567
   üõ´ T·ª´: N·ªôi B√†i (HAN) - 08:15
   üõ¨ ƒê·∫øn: ƒê√† N·∫µng (DAD) - 09:45
   ‚è±Ô∏è Th·ªùi gian bay: 1h30m
   üí∞ Gi√° v√©: 1,200,000 - 1,800,000 VND
   üõÑ H√†nh l√Ω: 7kg x√°ch tay + 20kg k√Ω g·ª≠i
   üí∫ Lo·∫°i m√°y bay: Airbus A320

3. ‚úàÔ∏è Bamboo Airways QH123
   üõ´ T·ª´: N·ªôi B√†i (HAN) - 09:30
   üõ¨ ƒê·∫øn: ƒê√† N·∫µng (DAD) - 11:00
   ‚è±Ô∏è Th·ªùi gian bay: 1h30m
   üí∞ Gi√° v√©: 1,300,000 - 1,900,000 VND
   üõÑ H√†nh l√Ω: 7kg x√°ch tay + 20kg k√Ω g·ª≠i
   üí∫ Lo·∫°i m√°y bay: Airbus A320

üí° Th√¥ng tin b·ªï sung:
- Gi√° v√© c√≥ th·ªÉ thay ƒë·ªïi t√πy th·ªùi ƒëi·ªÉm ƒë·∫∑t
- N√™n ƒë·∫∑t s·ªõm ƒë·ªÉ c√≥ gi√° t·ªët
- Ki·ªÉm tra ch√≠nh s√°ch h·ªßy/ƒë·ªïi v√© c·ªßa t·ª´ng h√£ng

NEVER just list websites. ALWAYS show specific flight information."""

        # Try to get the specific model
        try:
            self.model = genai.GenerativeModel('gemini-2.0-flash')
            print("Successfully initialized gemini-2.0-flash")
        except Exception as model_error:
            print(f"Error initializing gemini-2.0-flash: {str(model_error)}")
            # Fallback to gemini-pro
            print("Falling back to gemini-pro")
            self.model = genai.GenerativeModel('gemini-pro')

    def process(self, user_input: str) -> Dict[str, Any]:
        """Process flight-related queries."""
        try:
            logging.info(f"FlightAgent processing input: {user_input}")
            
            # Check if input contains flight-related keywords
            flight_keywords = ['chuy·∫øn bay', 'v√© m√°y bay', 'bay', 'flight']
            if not any(keyword in user_input.lower() for keyword in flight_keywords):
                return {
                    "status": "error",
                    "message": "Vui l√≤ng cung c·∫•p th√¥ng tin v·ªÅ chuy·∫øn bay b·∫°n mu·ªën t√¨m ki·∫øm."
                }
                
            # Use SERP API if available
            if self.serp_api_key and GoogleSearch is not None:
                # Try to extract locations and dates from the query
                from_location = None
                to_location = None
                date = None
                
                # Basic extraction of from/to locations
                from_patterns = [
                    r't·ª´\s+([A-Za-z\s]+)\s+ƒë·∫øn',
                    r't·ª´\s+([A-Za-z\s]+)',
                    r'([A-Za-z\s]+)\s+ƒë·∫øn'
                ]
                
                to_patterns = [
                    r'ƒë·∫øn\s+([A-Za-z\s]+)',
                    r't·ªõi\s+([A-Za-z\s]+)'
                ]
                
                for pattern in from_patterns:
                    matches = re.search(pattern, user_input, re.IGNORECASE)
                    if matches:
                        from_location = matches.group(1).strip()
                        break
                        
                for pattern in to_patterns:
                    matches = re.search(pattern, user_input, re.IGNORECASE)
                    if matches:
                        to_location = matches.group(1).strip()
                        break
                
                # If we have both locations, attempt to use SERP API
                if from_location and to_location:
                    logging.info(f"Extracted flight route: {from_location} to {to_location}")
                    try:
                        # Use SERP API to get flight info
                        search_params = {
                            'engine': 'google_flights',
                            'departure_id': from_location,
                            'arrival_id': to_location,
                            'type': '2',  # one-way flight
                            'hl': 'vi',
                            'api_key': self.serp_api_key
                        }
                        
                        search = GoogleSearch(search_params)
                        results = search.get_dict()
                        
                        if results and 'error' not in results:
                            # Format flight results using the model
                            results_summary = f"K·∫øt qu·∫£ t√¨m ki·∫øm chuy·∫øn bay t·ª´ {from_location} ƒë·∫øn {to_location}:\n\n"
                            results_summary += str(results)
                            
                            # Use AI to format the results nicely
                            formatted_response = self.model.generate_content(
                                f"B·∫°n l√† chuy√™n gia v·ªÅ chuy·∫øn bay. H√£y ƒë·ªãnh d·∫°ng th√¥ng tin n√†y th√†nh ph·∫£n h·ªìi h·ªØu √≠ch b·∫±ng ti·∫øng Vi·ªát v·ªõi emoji:\n\n{results_summary}"
                            )
                            
                            return {
                                "status": "success",
                                "content": formatted_response.text,
                                "raw_data": results
                            }
                    except Exception as search_error:
                        logging.error(f"Error using SERP API: {str(search_error)}")
                        # Fall back to AI-generated response
            else:
                # N·∫øu kh√¥ng c√≥ SERP_API_KEY, s·ª≠ d·ª•ng AI ƒë·ªÉ t·∫°o d·ªØ li·ªáu gi·∫£ l·∫≠p
                logging.info("SERP API not available for regular process, using AI-generated flight data instead")
                
                # Basic extraction of from/to locations
                from_location = None
                to_location = None
                
                from_patterns = [
                    r't·ª´\s+([A-Za-z\s]+)\s+ƒë·∫øn',
                    r't·ª´\s+([A-Za-z\s]+)',
                    r'([A-Za-z\s]+)\s+ƒë·∫øn'
                ]
                
                to_patterns = [
                    r'ƒë·∫øn\s+([A-Za-z\s]+)',
                    r't·ªõi\s+([A-Za-z\s]+)'
                ]
                
                for pattern in from_patterns:
                    matches = re.search(pattern, user_input, re.IGNORECASE)
                    if matches:
                        from_location = matches.group(1).strip()
                        break
                        
                for pattern in to_patterns:
                    matches = re.search(pattern, user_input, re.IGNORECASE)
                    if matches:
                        to_location = matches.group(1).strip()
                        break
                
                # Ki·ªÉm tra n·∫øu ƒë√£ x√°c ƒë·ªãnh ƒë∆∞·ª£c ƒë·ªãa ƒëi·ªÉm ƒëi v√† ƒë·∫øn
                if from_location and to_location:
                    # Ch·ªânh prompt cho Gemini
                    enhanced_prompt = f"""B·∫°n l√† chuy√™n gia v·ªÅ chuy·∫øn bay. 

Ng∆∞·ªùi d√πng ƒëang t√¨m ki·∫øm chuy·∫øn bay t·ª´ {from_location} ƒë·∫øn {to_location}.

H√£y t·∫°o d·ªØ li·ªáu th·ª±c t·∫ø v·ªÅ c√°c chuy·∫øn bay tr√™n tuy·∫øn n√†y, bao g·ªìm:
1. H√£ng h√†ng kh√¥ng (Vietnam Airlines, Vietjet Air, Bamboo Airways)
2. S·ªë hi·ªáu chuy·∫øn bay
3. Gi·ªù kh·ªüi h√†nh v√† ƒë·∫øn
4. Th·ªùi gian bay
5. Lo·∫°i m√°y bay
6. Gi√° v√© (ph·∫°m vi, VND)
7. H√†nh l√Ω x√°ch tay v√† k√Ω g·ª≠i

ƒê·ªãnh d·∫°ng k·∫øt qu·∫£ r√µ r√†ng v·ªõi emoji. Li·ªát k√™ √≠t nh·∫•t 4-5 l·ª±a ch·ªçn kh√°c nhau.
Th√™m c√°c l∆∞u √Ω h·ªØu √≠ch cho h√†nh kh√°ch.

C√¢u h·ªèi g·ªëc: {user_input}
"""
                    
                    # Generate response using Gemini with enhanced prompt
                    response = self.model.generate_content(enhanced_prompt)
                    
                    if not response or not hasattr(response, 'text'):
                        return {
                            "status": "error",
                            "message": "Kh√¥ng th·ªÉ t√¨m th√¥ng tin chuy·∫øn bay. Vui l√≤ng th·ª≠ l·∫°i."
                        }
                    
                    return {
                        "status": "success",
                        "content": response.text + "\n\n*(D·ªØ li·ªáu ƒë∆∞·ª£c t·∫°o b·ªüi AI, c√≥ th·ªÉ kh√¥ng ph·∫£n √°nh l·ªãch tr√¨nh th·ª±c t·∫ø)*"
                    }
            
            # Generate response using Gemini
            response = self.model.generate_content(
                f"{self.system_prompt}\n\nUser: {user_input}"
            )
            
            if not response or not hasattr(response, 'text'):
                return {
                    "status": "error",
                    "message": "Kh√¥ng th·ªÉ t√¨m th√¥ng tin chuy·∫øn bay. Vui l√≤ng th·ª≠ l·∫°i."
                }
            
            logging.info(f"FlightAgent response: {response.text}")
            return {
                "status": "success",
                "content": response.text
            }
            
        except Exception as e:
            logging.error(f"FlightAgent error: {str(e)}")
            return {
                "status": "error",
                "message": f"An error occurred: {str(e)}"
            }

    def process_with_context(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process flight-related queries with context.
        
        Args:
            input_data (Dict): Dictionary containing user_input, context, entities, history
            
        Returns:
            Dict: Response with flight information
        """
        try:
            user_input = input_data.get('user_input', '')
            context = input_data.get('context', {})
            entities = input_data.get('entities', {})
            history = input_data.get('history', [])
            
            logging.info(f"FlightAgent processing input with context: {user_input}")
            
            # Extract important information from context
            locations = entities.get('locations', [])
            if context.get('locations'):
                locations.extend(context.get('locations', []))
                
            # Use SERP API if available
            if self.serp_api_key and GoogleSearch is not None:
                # Try to extract from/to locations
                from_location = None
                to_location = None
                
                # First check entities
                if locations and len(locations) >= 2:
                    from_location = locations[0]
                    to_location = locations[1]
                else:
                    # Extract from text with regex
                    from_patterns = [
                        r't·ª´\s+([A-Za-z\s]+)\s+ƒë·∫øn',
                        r't·ª´\s+([A-Za-z\s]+)',
                        r'([A-Za-z\s]+)\s+ƒë·∫øn'
                    ]
                    
                    to_patterns = [
                        r'ƒë·∫øn\s+([A-Za-z\s]+)',
                        r't·ªõi\s+([A-Za-z\s]+)'
                    ]
                    
                    for pattern in from_patterns:
                        matches = re.search(pattern, user_input, re.IGNORECASE)
                        if matches:
                            from_location = matches.group(1).strip()
                            break
                            
                    for pattern in to_patterns:
                        matches = re.search(pattern, user_input, re.IGNORECASE)
                        if matches:
                            to_location = matches.group(1).strip()
                            break
                
                # If we have both locations, attempt to use SERP API
                if from_location and to_location:
                    logging.info(f"Extracted flight route from context: {from_location} to {to_location}")
                    try:
                        # Use SERP API to get flight info
                        search_params = {
                            'engine': 'google_flights',
                            'departure_id': from_location,
                            'arrival_id': to_location,
                            'type': '2',  # one-way flight
                            'hl': 'vi',
                            'api_key': self.serp_api_key
                        }
                        
                        search = GoogleSearch(search_params)
                        results = search.get_dict()
                        
                        if results and 'error' not in results:
                            # Get weather info if available
                            weather_info = ""
                            if context.get('supporting_info') and context['supporting_info'].get('agent') == 'weather':
                                weather_info = context['supporting_info'].get('content', '')
                            
                            # Format flight results using the model
                            results_summary = f"K·∫øt qu·∫£ t√¨m ki·∫øm chuy·∫øn bay t·ª´ {from_location} ƒë·∫øn {to_location}:\n\n"
                            results_summary += str(results)
                            
                            prompt = f"""B·∫°n l√† chuy√™n gia v·ªÅ chuy·∫øn bay. 
H√£y ƒë·ªãnh d·∫°ng th√¥ng tin n√†y th√†nh ph·∫£n h·ªìi h·ªØu √≠ch b·∫±ng ti·∫øng Vi·ªát v·ªõi emoji.

{results_summary}

"""
                            
                            # Add weather information if available
                            if weather_info:
                                prompt += f"\nTh√¥ng tin th·ªùi ti·∫øt t·∫°i ƒëi·ªÉm ƒë·∫øn:\n{weather_info}\n"
                                prompt += "\nH√£y nh·ªõ ƒë·ªÅ c·∫≠p ƒë·∫øn th·ªùi ti·∫øt t·∫°i ƒëi·ªÉm ƒë·∫øn trong ph·∫£n h·ªìi c·ªßa b·∫°n."
                            
                            # Use conversation history for personalization if available
                            if history and len(history) > 0:
                                prompt += "\n\nH√£y c√° nh√¢n h√≥a ph·∫£n h·ªìi d·ª±a tr√™n cu·ªôc tr√≤ chuy·ªán tr∆∞·ªõc ƒë√≥."
                            
                            # Use AI to format the results nicely
                            formatted_response = self.model.generate_content(prompt)
                            
                            return {
                                "status": "success",
                                "content": formatted_response.text,
                                "raw_data": results
                            }
                    except Exception as search_error:
                        logging.error(f"Error using SERP API with context: {str(search_error)}")
                        # Fall back to AI-generated response
            else: 
                # N·∫øu kh√¥ng c√≥ SERP_API_KEY, s·ª≠ d·ª•ng AI ƒë·ªÉ t·∫°o d·ªØ li·ªáu gi·∫£ l·∫≠p
                logging.info("SERP API not available, using AI-generated flight data instead")
                
                # Extract from_location and to_location from context if available
                from_location = None
                to_location = None
                
                # First check entities
                if locations and len(locations) >= 2:
                    from_location = locations[0]
                    to_location = locations[1]
                else:
                    # Extract from text with regex
                    from_patterns = [
                        r't·ª´\s+([A-Za-z\s]+)\s+ƒë·∫øn',
                        r't·ª´\s+([A-Za-z\s]+)',
                        r'([A-Za-z\s]+)\s+ƒë·∫øn'
                    ]
                    
                    to_patterns = [
                        r'ƒë·∫øn\s+([A-Za-z\s]+)',
                        r't·ªõi\s+([A-Za-z\s]+)'
                    ]
                    
                    for pattern in from_patterns:
                        matches = re.search(pattern, user_input, re.IGNORECASE)
                        if matches:
                            from_location = matches.group(1).strip()
                            break
                            
                    for pattern in to_patterns:
                        matches = re.search(pattern, user_input, re.IGNORECASE)
                        if matches:
                            to_location = matches.group(1).strip()
                            break
                
                # Ki·ªÉm tra n·∫øu ƒë√£ x√°c ƒë·ªãnh ƒë∆∞·ª£c ƒë·ªãa ƒëi·ªÉm ƒëi v√† ƒë·∫øn
                if from_location and to_location:
                    # Ch·ªânh prompt gi√∫p Gemini t·∫°o d·ªØ li·ªáu chuy·∫øn bay th·ª±c t·∫ø h∆°n
                    enhanced_prompt = f"""B·∫°n l√† chuy√™n gia v·ªÅ chuy·∫øn bay v√† l·ªãch tr√¨nh bay.
H√£y t·∫°o d·ªØ li·ªáu ch√≠nh x√°c, th·ª±c t·∫ø v·ªÅ c√°c chuy·∫øn bay t·ª´ {from_location} ƒë·∫øn {to_location}.
Cung c·∫•p:
1. S·ªë hi·ªáu chuy·∫øn bay th·ª±c (VN123, VJ567, QH912, v.v.)
2. Gi·ªù kh·ªüi h√†nh v√† ƒë·∫øn theo m√∫i gi·ªù ƒë·ªãa ph∆∞∆°ng
3. Th·ªùi gian bay 
4. Gi√° v√© d·ª± ki·∫øn (kho·∫£ng gi√°, VND)
5. H√£ng h√†ng kh√¥ng 
6. Lo·∫°i m√°y bay
7. Th√¥ng tin h√†nh l√Ω c∆° b·∫£n

ƒê·ªãnh d·∫°ng k·∫øt qu·∫£ r√µ r√†ng v·ªõi bi·ªÉu t∆∞·ª£ng emoji ph√π h·ª£p. ƒê·∫£m b·∫£o th√¥ng tin g·∫ßn v·ªõi th·ª±c t·∫ø nh·∫•t c√≥ th·ªÉ.
Li·ªát k√™ √≠t nh·∫•t 5 chuy·∫øn bay kh√°c nhau n·∫øu c√≥ th·ªÉ.
Th√™m l∆∞u √Ω h·ªØu √≠ch cho h√†nh kh√°ch d·ª±a tr√™n tuy·∫øn bay n√†y.
"""

                    # Get weather info if available
                    weather_info = ""
                    if context.get('supporting_info') and context['supporting_info'].get('agent') == 'weather':
                        weather_info = context['supporting_info'].get('content', '')
                    
                    if weather_info:
                        enhanced_prompt += f"\nTh√¥ng tin th·ªùi ti·∫øt t·∫°i ƒëi·ªÉm ƒë·∫øn:\n{weather_info}\n"
                        enhanced_prompt += "\nH√£y nh·ªõ ƒë·ªÅ c·∫≠p ƒë·∫øn th·ªùi ti·∫øt t·∫°i ƒëi·ªÉm ƒë·∫øn trong ph·∫£n h·ªìi c·ªßa b·∫°n."
                    
                    # Use conversation history for personalization if available
                    if history and len(history) > 0:
                        enhanced_prompt += "\n\nH√£y c√° nh√¢n h√≥a ph·∫£n h·ªìi d·ª±a tr√™n cu·ªôc tr√≤ chuy·ªán tr∆∞·ªõc ƒë√≥."
                    
                    # Generate response using Gemini
                    response = self.model.generate_content(enhanced_prompt)
                    
                    if not response or not hasattr(response, 'text'):
                        return {
                            "status": "error",
                            "message": "Kh√¥ng th·ªÉ t√¨m th√¥ng tin chuy·∫øn bay. Vui l√≤ng th·ª≠ l·∫°i."
                        }
                    
                    return {
                        "status": "success",
                        "content": response.text,
                        "note": "D·ªØ li·ªáu ƒë∆∞·ª£c t·∫°o b·ªüi AI, c√≥ th·ªÉ kh√¥ng ph·∫£n √°nh ƒë·∫ßy ƒë·ªß t√¨nh tr·∫°ng th·ª±c t·∫ø."
                    }
            
            # Check if we have supporting info from weather agent
            weather_info = ""
            if context.get('supporting_info') and context['supporting_info'].get('agent') == 'weather':
                weather_info = context['supporting_info'].get('content', '')
                if weather_info:
                    logging.info(f"Retrieved weather info: {weather_info}")
            
            # Enhanced prompt with context
            enhanced_prompt = f"""You are a flight booking expert. Your main task is to provide specific flight information. When users ask about flights, ALWAYS show actual flight details.

Query: {user_input}

Context information:
- Locations mentioned: {", ".join(locations) if locations else "No specific locations"}
"""

            # Add weather information if available
            if weather_info:
                enhanced_prompt += f"\nWeather information for destination:\n{weather_info}\n"
            
            # Add conversation history for context
            if history and len(history) > 0:
                recent_history = history[-3:] if len(history) > 3 else history
                history_text = "\nRecent conversation:\n"
                for message in recent_history:
                    role = message.get('role', 'unknown')
                    content = message.get('content', '')
                    history_text += f"- {role.capitalize()}: {content}\n"
                    
                enhanced_prompt += history_text

            enhanced_prompt += """
For flight queries, follow these rules:
1. NEVER just list websites
2. ALWAYS show specific flight information
3. Include actual flight details (times, prices, airlines)
4. If time of day is specified, prioritize those flights
5. If weather concerns exist, mention them in your response
6. Respond in Vietnamese with clear, structured information using emojis

Respond to the above query with detailed flight information.
"""
            
            # Generate response using Gemini
            response = self.model.generate_content(enhanced_prompt)
            
            if not response or not hasattr(response, 'text'):
                return {
                    "status": "error",
                    "message": "Kh√¥ng th·ªÉ t√¨m th√¥ng tin chuy·∫øn bay. Vui l√≤ng th·ª≠ l·∫°i."
                }
            
            logging.info(f"FlightAgent contextualized response: {response.text}")
            return {
                "status": "success",
                "content": response.text
            }
            
        except Exception as e:
            logging.error(f"FlightAgent error in process_with_context: {str(e)}")
            return {
                "status": "error",
                "message": f"An error occurred: {str(e)}"
            }

    async def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """Validate the input data."""
        if 'type' not in input_data:
            return False
        
        if input_data['type'] == 'search_flights':
            required_fields = ['from_city', 'to_city', 'date']
            return all(field in input_data for field in required_fields)
        elif input_data['type'] == 'get_flight_details':
            return 'flight_id' in input_data
        elif input_data['type'] == 'get_route_insights':
            required_fields = ['from_city', 'to_city']
            return all(field in input_data for field in required_fields)
        
        return False
        
    async def search_flights(self, from_city: str, to_city: str, date: str) -> Dict[str, Any]:
        """Search for flights between two cities on a specific date."""
        try:
            if not self._check_serp_api():
                return {
                    "status": "error",
                    "message": "Google Search Results is not available. Please install google-search-results package."
                }
            
            print(f"Searching for flights from {from_city} to {to_city} on {date}")
            
            # First, use Gemini to enhance the search query
            prompt = f"""
            Given a flight search from {from_city} to {to_city} on {date}, provide:
            1. Available flights with:
               - Flight numbers
               - Airlines
               - Departure and arrival times
               - Duration
               - Price ranges
               - Number of stops
               - Aircraft types
               - Baggage allowances
            2. Best booking options
            3. Alternative routes if available
            4. Travel tips for this route
            
            Format the response in Vietnamese with emojis and include ALL available flight information.
            """
            
            ai_insights = await self._generate_response(prompt)
            
            # Then perform the actual search
            search_params = {
                'engine': 'google_flights',
                'departure_id': from_city,
                'arrival_id': to_city,
                'outbound_date': date,
                'type': '2',  # 2 for one-way flights
                'hl': 'en',
                'gl': 'us',
                'api_key': self.serp_api_key
            }
            
            print("Making API request with params:", search_params)
            search = GoogleSearch(search_params)
            results = search.get_dict()
            
            print("API Response:", results)
            
            if 'flights_results' in results:
                # Use Gemini to analyze and summarize the results
                flights_text = str(results['flights_results'])
                summary = await self._summarize_text(flights_text)
                
                # Get additional insights
                analysis = await self._analyze_with_context(
                    flights_text,
                    f"Analyzing flight options from {from_city} to {to_city} on {date}"
                )
                
                return {
                    "status": "success",
                    "flights": results['flights_results'],
                    "count": len(results['flights_results']),
                    "ai_insights": ai_insights if ai_insights else None,
                    "summary": summary,
                    "analysis": analysis["content"] if analysis["status"] == "success" else None
                }
            else:
                print("No flights found in results")
                return {
                    "status": "error",
                    "message": "Kh√¥ng t√¨m th·∫•y chuy·∫øn bay ph√π h·ª£p. Vui l√≤ng th·ª≠ l·∫°i v·ªõi ng√†y kh√°c ho·∫∑c tuy·∫øn bay kh√°c.",
                    "raw_response": results
                }
                
        except Exception as e:
            print(f"Error in search_flights: {str(e)}")
            return {
                "status": "error",
                "message": str(e)
            }
            
    async def get_flight_details(self, flight_id: str) -> Dict[str, Any]:
        """Get detailed information about a specific flight."""
        try:
            if not self._check_serp_api():
                return {
                    "status": "error",
                    "message": "Google Search Results is not available"
                }
                
            params = {
                "engine": "google_flights",
                "flight_id": flight_id,
                "hl": "en",
                "gl": "us",
                "api_key": self.serp_api_key
            }
            
            search = GoogleSearch(params)
            results = search.get_dict()
            
            if 'flights_results' in results:
                flight_text = str(results['flights_results'][0])
                prompt = f"""
                Analyze this flight information and provide:
                1. Key highlights and features
                2. Potential issues or concerns
                3. Travel tips and recommendations
                4. Baggage and check-in information
                5. In-flight services
                6. Cancellation and change policies
                
                Flight data:
                {flight_text}
                """
                
                analysis = await self._generate_response(prompt)
                
                return {
                    "status": "success",
                    "flight": results['flights_results'][0],
                    "ai_analysis": analysis if analysis else None
                }
            else:
                return {
                    "status": "error",
                    "message": "Flight not found"
                }
                
        except Exception as e:
            print(f"Error in get_flight_details: {str(e)}")
            return {
                "status": "error",
                "message": str(e)
            }
            
    async def get_route_insights(self, from_city: str, to_city: str) -> Dict[str, Any]:
        """Get detailed insights about a specific route."""
        prompt = f"""
        Provide comprehensive insights about the flight route from {from_city} to {to_city}:
        1. Best time to travel
        2. Common airlines and their reputation
        3. Typical flight duration
        4. Price trends throughout the year
        5. Popular travel seasons
        6. Airport information
        7. Visa and entry requirements
        8. Local transportation options
        """
        
        return await self._generate_response(prompt)

    async def _generate_response(self, prompt):
        """Generate a response using Gemini."""
        if not self.model:
            print("Gemini model not initialized")
            return None
            
        try:
            print(f"Generating response for prompt: {prompt[:100]}...")
            response = self.model.generate_content(prompt)
            if response and hasattr(response, 'text'):
                print(f"Generated response: {response.text[:100]}...")
                return response.text
            else:
                print("No response text found in response object")
                return None
        except Exception as e:
            print(f"Error generating response: {str(e)}")
            return None 